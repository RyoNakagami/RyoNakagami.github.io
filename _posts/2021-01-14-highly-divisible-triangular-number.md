---
layout: post
title: "Highly divisible triangular numberの計算"
subtitle: "Project Euler Problem 12の解説"
author: "Ryo"
header-style: text
header-mask: 0.0
catelog: true
mathjax: true
purpose: 
tags:

- math
- 競技プログラミング
---



||概要|
|---|---|
|目的|Project Euler Problem 12の解説|
|参考|[高校数学の美しい物語～定期試験から数学オリンピックまで800記事～](https://mathtrain.jp/tagainiso)|

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [1. 今回のスコープ](#1-%E4%BB%8A%E5%9B%9E%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97)
  - [Project Euler Problem 12の問題分](#project-euler-problem-12%E3%81%AE%E5%95%8F%E9%A1%8C%E5%88%86)
- [2. 前提](#2-%E5%89%8D%E6%8F%90)
  - [命題: 「連続する整数は互いに素」の解説](#%E5%91%BD%E9%A1%8C-%E9%80%A3%E7%B6%9A%E3%81%99%E3%82%8B%E6%95%B4%E6%95%B0%E3%81%AF%E4%BA%92%E3%81%84%E3%81%AB%E7%B4%A0%E3%81%AE%E8%A7%A3%E8%AA%AC)
- [3. プログラミング方針](#3-%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E6%96%B9%E9%87%9D)
  - [モジュール](#%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB)
  - [(1) 任意の自然数の約数の個数を計算する関数](#1-%E4%BB%BB%E6%84%8F%E3%81%AE%E8%87%AA%E7%84%B6%E6%95%B0%E3%81%AE%E7%B4%84%E6%95%B0%E3%81%AE%E5%80%8B%E6%95%B0%E3%82%92%E8%A8%88%E7%AE%97%E3%81%99%E3%82%8B%E9%96%A2%E6%95%B0)
    - [疑似コード](#%E7%96%91%E4%BC%BC%E3%82%B3%E3%83%BC%E3%83%89)
  - [(2) 約数の数が入力された自然数より多い最小の三角数を返す関数](#2-%E7%B4%84%E6%95%B0%E3%81%AE%E6%95%B0%E3%81%8C%E5%85%A5%E5%8A%9B%E3%81%95%E3%82%8C%E3%81%9F%E8%87%AA%E7%84%B6%E6%95%B0%E3%82%88%E3%82%8A%E5%A4%9A%E3%81%84%E6%9C%80%E5%B0%8F%E3%81%AE%E4%B8%89%E8%A7%92%E6%95%B0%E3%82%92%E8%BF%94%E3%81%99%E9%96%A2%E6%95%B0)
    - [疑似コード](#%E7%96%91%E4%BC%BC%E3%82%B3%E3%83%BC%E3%83%89-1)
- [4. Pythonでの実行コード](#4-python%E3%81%A7%E3%81%AE%E5%AE%9F%E8%A1%8C%E3%82%B3%E3%83%BC%E3%83%89)
- [5. C言語でのソースコード](#5-c%E8%A8%80%E8%AA%9E%E3%81%A7%E3%81%AE%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 1. 今回のスコープ

- Project Euler Problem 12の解説

### Project Euler Problem 12の問題分

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
The first ten terms would be:

```raw
    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
```

Let us list the factors of the first seven triangle numbers:

```raw
     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28
```

We can see that 28 is the first triangle number to have over five divisors.
What is the value of the first triangle number to have over five hundred divisors?
 
## 2. 前提

- 連続する整数は互いに素

### 命題: 「連続する整数は互いに素」の解説

- (高校数学の美しい物語～定期試験から数学オリンピックまで800記事～より抜粋です)

背理法で証明する。 $n$ と $n+1$ が互いに素でないと仮定する。このとき，$n$ と $n+1$ の両方を割り切る整数 $p(\geq 2)$が存在する。
p の倍数どうしの差も p の倍数なので，$(n+1)$−n=1 も $p$ の倍数となる。これは $p\geq 2$ に矛盾。

## 3. プログラミング方針
### モジュール

- `find_factors`: 任意の自然数の約数の個数を計算する関数
- `find_factors_triangular_number`: 今回の本丸。約数の数が入力された自然数より多い最小の三角数を返す関数

### (1) 任意の自然数の約数の個数を計算する関数

- 今回は個数だけ良いので変える値は整数とします（リストや配列だとメモリを食べてしまうので）。
- searchの範囲は$\sqrt{N}$までとします。
- searchの範囲内でとある数が約数であると認められた場合、その約数に対応する約数が$\sqrt{N}$以上に存在することに留意
- 正の平方根が自然数の場合だけ注意

#### 疑似コード

```raw
PROCEDURE find_factors(int N)

    SET max_integer to root sqrt of N
    SET result to 0
    SET factor_candidate to 1

    FOR (factor_candidate; factor_candiate <= max_integer; factor_candiate++, step 1)
        IF N % factor_candidate ==0:
            result += 2
        END IF
    END FOR

    IF N == max_integer**2:
        result -= 1
    
    RETURN result  
END
```

### (2) 約数の数が入力された自然数より多い最小の三角数を返す関数

n番目の三角数T(n)は

$$
T(n) = \frac{n\times (n+1)}{2}
$$

と表せます。このとき、隣り合う正の整数は互いに素なのでT(n)の約数の個数($P(T(n))$と表記する)はnが偶数の場合

$$
P(T(n)) = P(n/2)\times P(n+1)
$$

と表せます。これを整理すると以下のようになります。

```raw
P(T(1)) = P(1) × P(2/2)
P(T(2)) = P(2/2) × P(3)
P(T(3)) = P(3) × P(4/2)
 
(以下略)
```

なので、n thの三角数の約数の個数を計算するとき、その計算式の第一項がn-1 thの三角数の約数の個数の式の第二項と対応することがわかるので、これを使います。

#### 疑似コード

```raw
PROCEDURE find_factors_triangular_number(N):
    
    SET INT result to 0
    SET INT 1st_term to 1
    SET INT 2nd_term to 0
    SET INT i to 0

    WHILE result < N:
        i = i + 1

        IF (i+1) % 2 ==0:
            2nd_term = find_factors(int((i + 1)/2))
        ELSE:
            2nd_term = find_factors((i +1))
        END IF
        
        result = 1st_term * 2nd_term
        1st_term = 2nd_term
    
    END WHILE

    RETURN i*(i+1)/2
```

## 4. Pythonでの実行コード

```py
def find_factors(num):
    res = 0
    i = 1
    max_counter = int(num**(1/2))
    
    while (i <= max_counter):
        if num % i ==0:
            res += 2
        i+=1

    if num == max_counter**2:
        res -= 1
    
    return res


def find_factors_triangular_number(N):
    
    res = 0
    current_fac = 1
    next_fac = 0
    index_num = 0

    while res < N:
        index_num+=1
        if (index_num+1) % 2 ==0:
            next_fac = find_factors(int((index_num + 1) / 2))
        else:
            next_fac = find_factors((index_num + 1))
        
        res = current_fac * next_fac
        current_fac = next_fac

    return int(index_num*(index_num + 1) / 2)

def main():
    i = 500
    print(i, find_factors_triangular_number(i))

if __name__ == "__main__":
    main()
```

## 5. C言語でのソースコード

```c
#include <stdio.h>
#include <math.h>

int find_factors(int N)
{
    int max_integer = 0;
    int result = 0;
    int factor_candidate = 1;

    max_integer = (int)sqrt(N);

    for (; factor_candidate <= max_integer; factor_candidate++)
    {
        if (N % factor_candidate == 0)
            result += 2;
    }

    if (N == max_integer*max_integer)
        result -= 1;
    
    return result;
}

int find_factors_triangular_number(int N)
{
    int result = 0;
    int first_term = 1;
    int second_term = 0;
    int i = 0;

    while (result < N)
    {
        i++;

        if ((i+1) % 2 == 0)
            second_term = find_factors(((i + 1) / 2));
        else
            second_term = find_factors((i + 1));
        
        result = first_term * second_term;
        first_term = second_term;
    }
    return i*(i+1)/2;
}


void main(void)
{
    printf("%d", find_factors_triangular_number(500));
}
```